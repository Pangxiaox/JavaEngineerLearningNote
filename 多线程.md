



# 多线程

### 1.并行与并发的区别

- 并行指两个或多个事件在同一时刻发生；并发指两个或多个事件在同一时间间隔发生。

- 并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。



### 2.进程与线程的区别

- 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。
- 线程是进程的一个实体，是CPU调度和分派的基本单位，是比程序更小的能独立运行的基本单位。
- 多线程可以实现并发操作。
- 进程是资源分配的最小单位，线程是程序执行的最小单位。



### 3.什么是守护线程（daemon thread）

- 守护线程是一个服务线程，准确来说就是服务其他的线程。
- 为了创建一个守护线程，需要在调用 `thread.start()` 方法之前调用 `thread.setDaemon()`方法。



### 4.创建线程的几种方式

1. ##### 继承Thread类创建线程类

   (1)定义Thread类的子类，并重写该类的run()方法，该方法的方法体代表了线程要完成的任务。因此把run()方法称为执行体。

   (2)创建Thread子类的实例，即创建了线程对象。

   (3)调用线程对象的start()方法启动线程。

   ```java
   public class MyThread extends Thread{
       
       public void run(){
           doSomething();
       }
       
       private void doSomething(){
           //omit
       }
   }
   ```

   ```java
   public class NewThread{
       public static void main(String[]args)
       {
           MyThread mythread=new MyThread();
           mythread.start();
           doSomething();
       }
       private static void doSomething(){
           //omit
       }
   }
   ```

2. ##### 通过Runnable接口创建线程类

   (1)定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

   (2)创建 Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

   (3)调用线程对象的start()方法来启动该线程。

```java
public class RunnableThread implements Runnable{
	@Override
	public void run() {
		// TODO Auto-generated method stub
		doSomeThing();
	}
    
	private void doSomeThing() {
		// TODO Auto-generated method stub
		System.out.println("我是一个线程方法");
	}
}
```

```java
public class NewThread {
	public static void main(String[] args) {
		Runnable runnable=new RunnableThread();
		Thread thread=new Thread(runnable);
		thread.start();//开启一个线程方法
	        //以下的方法可与上边的线程并发执行
		doSomething();
	}
    
	private static void doSomething() {
		// TODO Auto-generated method stub
    }
}
```

##### 	3.通过Callable和Future创建线程

（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。

（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

```java
import java.util.concurrent.Callable;
public class CallableThread implements Callable<String> {
    @Override
    public String call() throws Exception {
        // TODO Auto-generated method stub
        doSomeThing();
        return "需要返回的值";
    }
    
    private void doSomeThing() {
        // TODO Auto-generated method stub
        System.out.println("我是线程中的方法");
    }
}
```

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class test {
    public static void main(String[] args) {
        Callable<String> callable=new CallableThread();
        FutureTask<String> futureTask=new FutureTask<String>(callable);
        Thread thread=new Thread(futureTask);
        thread.start();//开启一个线程方法
        //以下的方法可与上边的线程并发执行
        doSomething();
        try {
            futureTask.get();//获取线程返回值
        } catch (InterruptedException | ExecutionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    
    private static void doSomething() {
        // TODO Auto-generated method stub
    }
}

```



### 5.runnable和callable有什么区别

1.Runnable接口中的 `run()`方法返回值是void，它所做的事情是执行 `run()`方法中的代码。

2.Callable接口中的 `call()`方法有返回值，是一个泛型，和Future、FutureTask配合可以获取异步执行的结果。



### 6.线程有哪些状态

1.创建状态：新创建了一个线程对象，还没有调用 `start()`方法。

2.就绪状态：当调用了线程对象的 `start()`方法之后，该线程进入了就绪状态，但此时线程调度程序还没把该线程设置为当前线程。在线程运行之后，从等待或者睡眠中回来之后，也会进入就绪状态。

▲处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。

3.运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程进入了运行状态，开始运行 `run()`方法中的代码。

4.阻塞状态：线程正在运行时，被暂停，通常时为了等待某个时间的发生（如某项资源就绪）之后再继续运行。 `sleep()`、`wait()`、`suspend()`等方法都可导致线程阻塞。

▲所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。

5.死亡状态：如果一个线程的 `run()`方法执行结束或者调用 `stop()`方法之后，该线程就会死亡。对于已经死亡的线程，无法再使用 `start()`方法令其进入就绪状态。



### 7.sleep()和wait()方法有什么区别

1. `sleep()`方法是Thread类的静态方法，让调用线程进入睡眠状态，让出执行机会给其他的线程，等到休眠时间结束之后，线程进入就绪状态和其他线程一起竞争CPU的执行时间。调用此方法不会释放锁对象。因而，当一个synchronized块（同步代码块）中调用了此方法，线程虽然进入了休眠，但其他线程无法访问它的锁对象。

2. `wait()`方法是Object类的方法，当一个线程执行到此方法时，它就进入到一个和该对象相关的等待池，同时释放锁对象，使得其他线程可以访问。可通过 `notify()`或 `notifyall()`方法来唤醒等待的线程。

3. （a) sleep()方法必须传入参数，参数就是休眠时间，时间到了就会自动醒来。

      (b) wait()方法可以传入参数也可以不传入参数，传入参数就是在参数结束的时间后开始等待，不穿如参数就是直接等待。



### 8.notify()和notifyAll()有什么区别

1.如果线程调用了对象的 `wait()`方法，那么线程便会处于该对象的等待池中，等待池中的线程不会竞争该对象的锁。

2.调用了 `notify()`方法后只有一个随机的线程会由等待池进入锁池，而 `notifyAll()`方法会将该对象等待池内所有线程都移动到锁池中，等待锁竞争。

▲锁池中的线程会去竞争该对象锁

3.优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 `wait()`方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

⭐一般采用 `notifyAll()`方法



### 9.线程的run()和start()方法有什么区别

1.`start()`方法启动一个线程，真正实现了多线程运行。这时候无需等待run方法体代码执行完毕，可以直接继续执行下面的代码，这时线程处于就绪状态，并没有运行。然后通过Thread类调用方法 `run()`来完成其运行状态，这里的 `run()`称为线程体，包含了要执行的这个线程的内容。 `run()`方法运行结束，此线程终止，然后CPU再调度其他线程。

2.`run()`方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用 `run()`方法相当于调用了一个普通函数。直接使用 `run()`方法必须等待 `run()`方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要用 `start()`方法而不是 `run()`方法。

▲demo1输出 pingpong  、demo2输出pongping

```java
public class demo1 {
	public static void main(String args[]) {  
        Thread t = new Thread() {  
            public void run() {  
                pong();  
            }  
        };  
        t.start();  
//        t.run();
        System.out.print("ping");  
    }  
    static void pong() {  
        System.out.print("pong");  
    }
}
```

```java
public class demo2 {
	public static void main(String args[]) {  
        Thread t = new Thread() {  
            public void run() {  
                pong();  
            }  
        };  
 //       t.start();  
          t.run();
        System.out.print("ping");  
    }  
    static void pong() {  
        System.out.print("pong");  
    }
}
```



### 10.创建线程池的几种方式

参考自：https://blog.csdn.net/qq_38408785/article/details/91383959

Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。

##### 1.newFixedThreadPool(int nThreads)

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class test {
    public static void main(String[] args) {
        //1.创建可固定长度的线程池
        ExecutorService newExecutorService = Executors.newFixedThreadPool(5);
        //创建了10个线程
        for (int i = 0; i < 10; i++) {
            int temp = i;
            newExecutorService.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("threadName;"+Thread.currentThread().getName()+",i"+temp);
                }
            });
        }
    }
}
```

输出结果：

threadName;pool-1-thread-5,i4
threadName;pool-1-thread-3,i2
threadName;pool-1-thread-4,i3
threadName;pool-1-thread-2,i1
threadName;pool-1-thread-1,i0
threadName;pool-1-thread-2,i8
threadName;pool-1-thread-4,i7
threadName;pool-1-thread-3,i6
threadName;pool-1-thread-5,i5
threadName;pool-1-thread-1,i9

##### 2.newCachedThreadPool()

创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class test {
    public static void main(String[] args) {
        //1.创建可缓存的线程池，可重复利用
        ExecutorService newExecutorService = Executors.newCachedThreadPool();
        //创建了10个线程
        for (int i = 0; i < 10; i++) {
            int temp = i;
            newExecutorService.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("threadName;"+Thread.currentThread().getName()+",i"+temp);
                }
            });
        }
    }
}
```

输出结果：

threadName;pool-1-thread-1,i3
threadName;pool-1-thread-5,i8
threadName;pool-1-thread-5,i2
threadName;pool-1-thread-1,i6
threadName;pool-1-thread-1,i9
threadName;pool-1-thread-7,i4
threadName;pool-1-thread-6,i1
threadName;pool-1-thread-3,i7
threadName;pool-1-thread-4,i0
threadName;pool-1-thread-2,i5

##### 3.newSingleThreadExecutor()

单线程的Executor,它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它，特点是能确保依照任务在队列中的顺序来串行执行。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class test {
    public static void main(String[] args) {
        //1.创建单线程
        ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            newSingleThreadExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    System.out.println("index:" + index);
                    try {
                        Thread.sleep(200);
                    } catch (Exception e) {
                        // TODO: handle exception
                    }
                }
            });
        }
        newSingleThreadExecutor.shutdown();
    }
}
```

输出结果：

index:0
index:1
index:2
index:3
index:4
index:5
index:6
index:7
index:8
index:9

##### 4.newScheduledThreadPool(int corePoolSize)

创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class test {
    public static void main(String[] args) {
        //1.创建可定时线程池
        ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(5);
        for (int i = 0; i < 10; i++) {
            final int temp = i;
            newScheduledThreadPool.schedule(new Runnable() {
                public void run() {
                    System.out.println("i:" + temp);
                }
            }, 3, TimeUnit.SECONDS);//延迟3秒执行
        }
    }
}
```

输出结果：

i:4
i:3
i:2
i:0
i:1
i:8
i:7
i:6
i:5
i:9



### 11.线程池有哪些状态

![Image text](https://github.com/Pangxiaox/JavaEngineerLearningNote/blob/master/Notes-Pic/test.jpg)



### 12.线程池中submit()和execute()方法有什么区别

- 接收的参数不一样

   `execute()`只能执行Runnable类型任务，`submit()`方法可以执行Runnable和Callable类型任务

- `submit()`有返回值而 `execute()`没有

  `submit()`方法可以提供 Future < T > 类型返回值

- `submit()`方法方便Exception处理



### 13.Java程序中怎么保证多线程的运行安全

- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作（atomic，synchronized)
- 可见性：一个线程对主内存的修改可以及时地被其他线程看到（synchronized,volatile)
- 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序（happens-before原则）

→导致原因：

- 缓存导致的可见性问题
- 线程切换带来的原子性问题
- 编译优化带来的有序性问题



### 14.多线程锁的升级原理是什么

级别从低到高依次为：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁 。这几个状态会随着竞争情况而逐渐升级。锁可以升级但不能降级。

![Image text](https://github.com/Pangxiaox/JavaEngineerLearningNote/blob/master/Notes-Pic/lock.png)

- 无锁：没有对资源进行锁定，所有线程都可以访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直至修改成功。
- 偏向锁：偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。
- 轻量级锁：轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。
- 重量级锁：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock（互斥锁） 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

▲关于自旋

1. 在物理机器有多个处理器的情况下，当两个或以上的线程同时并行执行时，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。

2. 如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。

3. 自适应自旋锁（适应性自旋锁）意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

   ⭐Brief Summary

   偏向锁通过对比 Mark Word 解决加锁问题，避免执行CAS操作。

   轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。

   重量级锁是将除了拥有锁的线程以外的线程都阻塞。



### 15.什么是死锁（Deadlock）

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。



### 16.怎么防止死锁

死锁的四个必要条件：

- 互斥条件：进程对所分配到的资源不允许其他进程进行访问，如果其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
- 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但又对自己获得的资源保持不放。
- 不可剥夺条件：对于进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放。
- 环路等待条件：进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系。

▲只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



### 17.ThreadLocal是什么，有哪些使用场景

线程局部变量，是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但在管理环境下（如Web服务器）使用线程局部变量的时候要小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成之后没有释放，Java应用就存在内存泄漏的风险。



### 18.说一下synchronized底层实现原理

synchronized可以保证方法或代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

使用synchronzied的3种方式：

- 修饰实例方法：作用于当前实例加锁，进入同步代码前要获取当前实例的锁。
- 修饰静态方法：作用于当前类对象加锁，进入同步代码前要获取当前类对象的锁。
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码前要获得给定对象的锁。

以下参考自 https://blog.csdn.net/javazejian/article/details/72828483

##### 修饰实例方法

```java
public class test implements Runnable{
    //共享资源(临界资源)
    static int i=0;
    public synchronized void increase(){
        i++;
    }
    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        test instance=new test();
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(i);//输出2000000
    }
}
```

由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。当前线程的锁是实例对象instance。

▲当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法。

```java
public class test implements Runnable{
    static int i=0;
    public synchronized void increase(){
        i++;
    }
    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new test());//new 新实例
        Thread t2=new Thread(new test());//new 新实例
        t1.start();
        t2.start();
        //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回
        t1.join();
        t2.join();
        System.out.println(i);//输出结果不唯一，如1236615、1063927、1341400，但不为2000000
    }
}
```

存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。

##### 修饰静态方法

```java
public class test implements Runnable{
    static int i=0;

    public static synchronized void increase(){
        i++;
    }
    
    //非静态,访问时锁不一样不会发生互斥
    public synchronized void increase4Obj(){
        i++;
    }

    @Override
    public void run() {
        for(int j=0;j<1000000;j++){
            increase();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new test());
        Thread t2=new Thread(new test());
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);//输出2000000
    }
}
```

访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。

##### 修饰代码块

```java
public class test implements Runnable{
    static test instance=new test();
    static int i=0;
    @Override
    public void run() {
        //省略其他耗时操作....
        //使用同步代码块对变量i进行同步操作,锁对象为instance
        synchronized(instance){
            for(int j=0;j<1000000;j++){
                i++;
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);//输出2000000
    }
}
```

每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行`i++;`操作。

```java
//class对象锁    
synchronized(test.class){
            for(int j=0;j<1000000;j++){
                i++;
            }
        }

//this,当前实例对象锁
synchronized(this){
            for(int j=0;j<1000000;j++){
                i++;
            }
        }
```

还可以使用this对象(代表当前实例)或者当前类的class对象作为锁。



### 19.synchronized和volatile的区别是什么

