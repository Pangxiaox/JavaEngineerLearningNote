# 多线程

### 1.并行与并发的区别

- 并行指两个或多个事件在同一时刻发生；并发指两个或多个事件在同一时间间隔发生。

- 并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。



### 2.进程与线程的区别

- 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。
- 线程是进程的一个实体，是CPU调度和分派的基本单位，是比程序更小的能独立运行的基本单位。
- 多线程可以实现并发操作。
- 进程是资源分配的最小单位，线程是程序执行的最小单位。



### 3.什么是守护线程（daemon thread）

- 守护线程是一个服务线程，准确来说就是服务其他的线程。
- 为了创建一个守护线程，需要在调用 `thread.start()` 方法之前调用 `thread.setDaemon()`方法。



### 4.创建线程的几种方式

1. 继承Thread类创建线程类

   (1)定义Thread类的子类，并重写该类的run()方法，该方法的方法体代表了线程要完成的任务。因此把run()方法称为执行体。

   (2)创建Thread子类的实例，即创建了线程对象。

   (3)调用线程对象的start()方法启动线程。

   ```java
   public class MyThread extends Thread{
       
       public void run(){
           doSomething();
       }
       
       private void doSomething(){
           //omit
       }
   }
   ```

   ```java
   public class NewThread{
       public static void main(String[]args)
       {
           MyThread mythread=new MyThread();
           mythread.start();
           doSomething();
       }
       private static void doSomething(){
           //omit
       }
   }
   ```

2. 通过Runnable接口创建线程类

   (1)定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

   (2)创建 Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

   (3)调用线程对象的start()方法来启动该线程。

```java
public class RunnableThread implements Runnable{
	@Override
	public void run() {
		// TODO Auto-generated method stub
		doSomeThing();
	}
    
	private void doSomeThing() {
		// TODO Auto-generated method stub
		System.out.println("我是一个线程方法");
	}
}
```

```java
public class NewThread {
	public static void main(String[] args) {
		Runnable runnable=new RunnableThread();
		Thread thread=new Thread(runnable);
		thread.start();//开启一个线程方法
	        //以下的方法可与上边的线程并发执行
		doSomething();
	}
    
	private static void doSomething() {
		// TODO Auto-generated method stub
    }
}
```

​	3.通过Callable和Future创建线程

（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。

（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

```java
import java.util.concurrent.Callable;
public class CallableThread implements Callable<String> {
    @Override
    public String call() throws Exception {
        // TODO Auto-generated method stub
        doSomeThing();
        return "需要返回的值";
    }
    
    private void doSomeThing() {
        // TODO Auto-generated method stub
        System.out.println("我是线程中的方法");
    }
}
```

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class test {
    public static void main(String[] args) {
        Callable<String> callable=new CallableThread();
        FutureTask<String> futureTask=new FutureTask<String>(callable);
        Thread thread=new Thread(futureTask);
        thread.start();//开启一个线程方法
        //以下的方法可与上边的线程并发执行
        doSomething();
        try {
            futureTask.get();//获取线程返回值
        } catch (InterruptedException | ExecutionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    
    private static void doSomething() {
        // TODO Auto-generated method stub
    }
}

```



### 5.runnable和callable有什么区别

1.Runnable接口中的 `run()`方法返回值是void，它所做的事情是执行 `run()`方法中的代码。

2.Callable接口中的 `call()`方法有返回值，是一个泛型，和Future、FutureTask配合可以获取异步执行的结果。



### 6.线程有哪些状态

1.创建状态：新创建了一个线程对象，还没有调用 `start()`方法。

2.就绪状态：当调用了线程对象的 `start()`方法之后，该线程进入了就绪状态，但此时线程调度程序还没把该线程设置为当前线程。在线程运行之后，从等待或者睡眠中回来之后，也会进入就绪状态。

▲处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。

3.运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程进入了运行状态，开始运行 `run()`方法中的代码。

4.阻塞状态：线程正在运行时，被暂停，通常时为了等待某个时间的发生（如某项资源就绪）之后再继续运行。 `sleep()`、`wait()`、`suspend()`等方法都可导致线程阻塞。

▲所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。

5.死亡状态：如果一个线程的 `run()`方法执行结束或者调用 `stop()`方法之后，该线程就会死亡。对于已经死亡的线程，无法再使用 `start()`方法令其进入就绪状态。