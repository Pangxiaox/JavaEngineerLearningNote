# 计算机网络

### ⭐1. HTTP状态码

- 1XX：通知。1XX系列响应代码仅在与HTTP服务器沟通时使用
- 2XX：成功。2XX系列响应代码表明操作成功了。
- 3XX：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。
- 4XX：客户端错误。这些响应代码表明客户端出现错误。
- 5XX：服务端错误。这些响应代码表明服务器端出现错误。

| 状态码 | 消息                  | 描述                                                         |
| :----- | --------------------- | ------------------------------------------------------------ |
| 200    | OK                    | 正常，请求被确认                                             |
| 400    | Bad Request           | 服务器不理解请求的语法                                       |
| 500    | Internal Server Error | 服务器内部错误，无法完成请求                                 |
| 301    | Moved Permanently     | 被请求的页面移动到了新的URL下                                |
| 404    | Not Found             | 服务器无法找到所请求的页面                                   |
| 307    | Temporary Redirect    | 被请求的页面暂时性移动到新的URL下                            |
| 403    | Forbidden             | 禁止访问所请求的页面                                         |
| 502    | Bad Gateway           | 作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应 |



### 2. forward（转发）和redirect（重定向）的区别

| 区别项     | forward                                                      | redirect                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据共享   | 转发页面和转发到的页面可以共享request里面的数据              | 不能共享数据                                                 |
| 地址栏显示 | 服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址 | 服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL |
| 本质区别   | 转发是服务器行为，浏览器只做了一次访问请求                   | 重定向是客户端行为，浏览器至少做了两次访问请求               |



### ⭐3. TCP和UDP的区别

| 区别项           | TCP                                                    | UDP                                        |
| ---------------- | ------------------------------------------------------ | ------------------------------------------ |
| 是否连接         | 面向连接（三次握手）                                   | 无连接                                     |
| 传输可靠性       | 可靠                                                   | 不可靠，尽最大努力交付                     |
| 速度             | 慢                                                     | 快                                         |
| 相关机制         | 在数据传递时，有确认、滑动窗口、选择重传、拥塞控制机制 | 无确认、滑动窗口、选择重传、拥塞控制等机制 |
| 适用场景         | 对网络通讯质量有要求，整个数据要准确无误地传递给对方   | 实时应用（实时游戏等）                     |
| 系统资源需求     | 对系统资源要求较多                                     | 对系统资源要求较少                         |
| 对应的应用层协议 | FTP、SMTP、HTTP、TELNET                                | DNS、SNMP、DHCP                            |



### ⭐4. TCP的三次握手和四次挥手

##### 4.1 TCP三次握手和四次挥手图示





##### 4.2 TCP为什么是三次握手而不是两次握手？

- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认



##### 4.3 TCP关闭连接时为什么是四次挥手？

关闭连接时，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，并且服务端也未必全部数据都发送给对方了，所以服务端可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务端的ACK和FIN一般都会分开发送，从而导致多了一次。



##### 4.4 TCP四次挥手时为什么需要TIME_WAIT（一般等待2MSL）？

- 为了保证服务端能收到客户端的确认应答。

若客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端就无法正常关闭。

- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。

客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文



### 5. TCP粘包现象和解决措施

- 当连续发送数据时，由于tcp协议的nagle算法，会将较小的内容拼接成大的内容，一次性发送到服务器端，因此造成粘包。

解决措施：可以在两次send（）直接使用recv（）来阻止连续发送的情况发生

- 当发送内容较大时，由于服务器端的recv（buffer_size）方法中的buffer_size较小，不能一次性完全接收全部内容，因此在下一次请求到达时，接收的内容依然是上一次没有完全接收完的内容，因此造成粘包现象。

解决措施：产生粘包的原因是接收方的无边界接收，因此发送端可以在发送数据之前向接收端告知发送内容的大小。



### ⭐6. TCP/IP协议栈和OSI七层模型

##### 6.1 TCP/IP协议栈

|   **应用层**   |
| :------------: |
|   **传输层**   |
|   **网络层**   |
| **数据链路层** |
|   **物理层**   |

##### 6.2 OSI七层模型

| 协议层     | 功能描述                                               | 相关协议                           |
| ---------- | ------------------------------------------------------ | ---------------------------------- |
| 应用层     | 提供应用程序访问OSI环境的手段                          | HTTP、SNMP、FTP、DNS、SMTP、Telnet |
| 表示层     | 为应用层进程提供格式化的表示和转换数据服务             |                                    |
| 会话层     | 进程间的对话也称会话，会话层管理不同主机各进程间的会话 |                                    |
| 传输层     | 提供数据传输的端到端的接口                             | TCP、UDP                           |
| 网络层     | 为数据包选择路由                                       | IP、ICMP、RIP、OSPF、BGP           |
| 数据链路层 | 传输有地址的帧，错误检测功能                           | ARP、RARP                          |
| 物理层     | 以二进制数据形式在物理媒体上传输数据                   | IEEE802                            |



### 7. 如何实现跨域请求？

##### 7.1 什么是跨域

跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP请求

**前端发起ajax请求的目标（域名+端口）与当前源（当前域名+端口）不匹配，此时这种请求就是跨域请求**。

##### 7.2 如何避免跨域请求

- 更改后端域名，保持和当前origin一致，这样直接就是同源请求，无需考虑跨域的种种限制
- 如果后端域名无法变更，跨域避免不了的时候，将采取相应措施实现跨域请求

##### 7.3 实现跨域请求的方法

- 后端更改HTTP响应头部实现跨域

此方法的思路就是遵循HTTP的CORS规范，返回指定的HTTP头部给前端，放行特定域名（或所有域名）的跨域请求。

- 反向代理实现跨域（如nginx的配置）

此解决方案是在运维层面通过配置一个反向代理服务器来将前端发送过来的请求反代到真实的后端服务器上，此时反向代理服务器的域名和前端域名保持一致，就不会触发跨域。

前端（域名A） →  反向代理（域名A）→ 后端服务器（域名B）

- 通过http-proxy-middleware实现跨域

此中间件本质上扮演的角色也相当于一个反向代理服务器，通过代理的方式将请求转发给后端，以此来实现跨域。此种方式实现的好处在于不需要运维层面的支持，只需要前端工程师做好配置即可，而且此插件可以非常方便的集成在webpack中，一般用来给前端工程师在本地环境开发调试接口时使用。



### 8. 从输入URL到页面加载发生了什么？

1.DNS解析

2.TCP连接

3.发送HTTP请求

4.服务器处理请求并返回HTTP报文

5.浏览器解析渲染页面

6.连接结束



### 9. HTTP和HTTPS的区别

- 端口：HTTP默认端口80，HTTPS默认端口443
- 安全性：HTTP协议运行在TCP上，所有传输内容都是明文；HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP上，所有传输内容都经过加密。HTTP安全性没有HTTPS高
- 资源消耗：HTTPS比HTTP耗费更多服务器资源



### 10. HTTP长连接和短连接

- 短连接：在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
- 长连接：从HTTP/1.1起，默认使用长连接。当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。



### 11. Cookie和Session的区别

Cookie和Session都是用来跟踪浏览器用户身份的会话方式。

| 区别项       | Cookie             | Session                  |
| ------------ | ------------------ | ------------------------ |
| 主要作用     | 保存用户信息       | 通过服务端记录用户的状态 |
| 数据存储位置 | 客户端（浏览器端） | 服务器端                 |
| 安全性       | 较低               | 较高                     |



### 12. URI和URL的区别

- URI（Uniform Resource Identifier)是统一资源标识符，可以唯一标识一个资源。
- URL（Uniform Resource Location)是统一资源定位符，可以提供该资源的路径，它是一种具体URI。

